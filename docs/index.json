[{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":""},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"Neural Discrete Representation Learning\n","permalink":"http://localhost:1313/posts/vqvae/","title":""},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"Neural Discrete Representation Learning\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Git"},{"content":"Neural Discrete Representation Learning\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Git"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Git"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" []\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [Neural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [vaNeural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [van den Oord A., Neural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [van den Oord A., Vinyals O.Neural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [van den Oord A., Vinyals O. and Neural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [van den Oord A., Vinyals O. and KavukcuoNeural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" [van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n主要 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 V 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 VQ-VAE 的 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者希望 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习, 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习, 给定任意的模式, 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习, 给定任意的模式, 编码成 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习, 给定任意的模式, 编码成离散的表示. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文的\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. 我们知道\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块: 1.\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $q($ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\rightarrrow z$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\rightarrow z$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z \\in \\mathbb{R}^d$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z \\in \\mathbb{R}^d$, 通常 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z \\in \\mathbb{R}^d$, 注意 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z \\in \\mathbb{R}^d$, 它实际上是 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi: x \\in \\mathbb{R}^D \\rightarrow z \\in \\mathbb{R}^d$, 它实际上扮演的是一个厚颜 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp()\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi)\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi),\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi),\r$$ 从该分布 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi),\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi)\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如最为常见的 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma)$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从gai 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样ji\u0026rsquo;ke 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\theta$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它讲yin\u0026rsquo;bian\u0026rsquo;l 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它讲yin\u0026rsquo;bian\u0026rsquo;l 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它讲yin\u0026rsquo;bianl 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它讲yin\u0026rsquo;bian\u0026rsquo;l 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它讲隐变量 $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ yin\u0026rsquo;she 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射hui 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rq(x|z; \\Phi)\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rq(x|z; \\Phi);\r$$ 还有一个先验分布 $$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rp(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rq(x|z; \\Phi);\r$$ 还有一个先验分布 $p$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rq(x|z; \\Phi);\r$$ 还有一个先验分布 $p$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. VAE 的训练目标是\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. VAE 的训练目标是极大似然: $$\n$$\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{array}{ll}\r\\end{array}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align}{ll}\r\\end{array}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align}{ll}\r\\end{align}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align}{ll}\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}{ll}\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\rx\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\rx\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. VAE 的训练目标是极大似然: $$ \\begin{align*}\n\\end{align*} $$\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x)\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) =\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) = \\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) = \\log \\int\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) = \\log \\int p(x, z) \\mathrm{d}\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) = \\log \\int p(x, z) \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int \\frac{p(x, z) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int \\frac{p(x, z)}{} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int \\frac{p(x, z)}{q} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int \\frac{p(x, z)}{q()} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z + \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z + \\\\\r\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z + \\\\\r\\ge \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\ge \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}()\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q)\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi})\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi} \\| )\\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z| z; \\Phi)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log \\frac{p(z) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. VAE 的训练目标是极大似然: $$ \\begin{align*} \\log p(x) \u0026amp;= \\log \\int p(x, z) \\mathrm{d}z \\ \u0026amp;= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\ \u0026amp;= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\ \u0026amp;\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\ \u0026amp;= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z + \\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\n\\end{align*} $$\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z))\\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{q} \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{q} \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{q_{\\phi}} \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi).\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= -\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi).\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi).\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{}.\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ 核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个重构损失\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL san\u0026rsquo;du\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是)\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加)\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity )\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 ()\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p$)\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的思想 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rq(x)\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow $$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\right\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}S_{}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - \\|\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e\\|\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 $$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 $E$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ er\u0026rsquo;bu\u0026rsquo;shi ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $k$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow z \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\Phi(x) \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|z - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $\\phi(x)$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单: 预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z)\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) = $$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. 容易发现, 这其实相当于我们的后验分布为: $$ q(z|x; \\phi) = \\begin{array}{ll}\n\\end{array} $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\begin{array}{ll}\r1 \u0026 q\r\\end{array}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 q\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 \\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 \\phi(x)\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 \\phi(x) \\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 \\phi(x)\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 \\phi(x)\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\| \\\\\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\| \\\\\r0 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\| \\\\\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\| \\\\\r0 \u0026 otherwise\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题,\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源: 1.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 由于gai\u0026rsquo;lü ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 由于概率 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, zh ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $z$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度 ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 str\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 str\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator,\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator, 另外设计了\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator, 另外设计了另外两个损失用于训练 $\\phi$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator, 另外设计了另外两个损失用于训练 $\\phi$ 以及 codebook $\\mathb$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator, 另外设计了另外两个损失用于训练 $\\phi$ 以及 codebook $\\mathbf{E}$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. 对于第二点, 作者建议采取 straight-through estimator, 另外设计了另外两个损失用于训练 $\\phi$ 以及 codebook $E$: $$\n$$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x)\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z)\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi)\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) +\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} $$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x))\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\text{sg} (\\phi(x) - e_{k^*}\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\phi(x) - e_{k^*}\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\phi(x) - \\text{sg} (e_{k^*}\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2\r$$ ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数.\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注:\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through es\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nx ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nx = x - ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() z_q:\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() z_q: $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - z_q\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() z_q: $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|e_{k^*}; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() z_q: $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() z_q: $$\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() ","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [[of]]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [[PyTorch]]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [PyTorch]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [PyTorch]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [PyTorch]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" van den Oord A., Vinyals O. and Kavukcuoglu K. Neural Discrete Representation Learning. NeurIPS, 2017.\n预备工作 作者的目的是实现离散化的表示学习: 给定任意的模式, 编码成离散的表示.\n既然本文是居于 VAE (变分自编码) 的框架实现的, 我们得对变分自编码有一个初步的了解. VAE 主要包含三个模块:\nEncoder $\\phi$: 它讲输入 $x \\in \\mathbb{R}^D$ 映射到一个分布: $$\rq(z|x; \\phi).\r$$ 比如当服从的高斯分布, 实质上 $\\phi(x) \\rightarrow (\\mu, \\sigma) \\rightarrow \\mathcal{N}(\\mu, \\sigma^2)$, 然后 $z$ 从该分布中采样即可; Decoder $\\Phi$: 它将隐变量 $z$ 映射回 (通常来说) $x$ 的空间: $$\rp(x|z; \\Phi);\r$$ 还有一个先验分布 $p(z)$ 用于辅助训练. $$\r\\begin{align*}\r\\log p(x) \u0026= \\log \\int p(x, z) \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x, z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\log \\int q(z|x; \\phi) \\cdot \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026\\ge \\int q(z|x; \\phi) \\log \\frac{p(x| z; \\Phi) p(z)}{q(z|x; \\phi)} \\mathrm{d}z \\\\\r\u0026= \\int q(z|x; \\phi) \\log \\frac{p(z)}{q(z|x; \\phi)} \\mathrm{d}z +\r\\int q(z|x; \\phi) \\log p(x|z; \\Phi) \\mathrm{d}z \\\\\r\u0026= \\underbrace{-\\mathbf{KL}(q_{\\phi}\\| p(z)) +\r\\mathbb{E}_{z \\sim q_{\\phi}} \\log p(x|z; \\Phi)}_{\\text{ELBO}}.\r\\end{align*}\r$$ ELBO 包括一个和先验分布的 KL 散度 (这部分通常是增加隐变量的 diversity 的), 以及一个正常的交叉熵 (如果 $p_{\\Phi}$ 也是一个高斯, 则通常称之为重构损失).\n核心思想 VQ-VAE 的希望 $z$ 不再局限于连续的向量, 而是离散的值, 做法其实极为简单:\n预设一个 codebook $E \\in \\mathbb{R}^{K \\times d}$; 给定一个输入 $x$, 其对应的离散值为 $$\rx \\rightarrow \\phi(x) \\rightarrow \\text{argmin}_{k} \\|\\phi(x) - e_k\\|,\r$$ 其中 $e_k$ 表示 codebook $E$ 中 $k$-th 行. 接下来, decoder 部分的输入将是 $e_{k^*}$ 而不再是 $z$ 了. $$\rq(z = e_{k^*}|x; \\phi) =\r\\left \\{\r\\begin{array}{ll}\r1 \u0026 k^* = \\text{argmin}_{k} \\|\\phi(x) - e_k\\|, \\\\\r0 \u0026 otherwise.\r\\end{array}\r\\right .\r$$ 但是这里其实有一个大问题, $\\phi$ 的训练梯度来源:\nKL 散度, 但是上述的概率实际上的 \u0026lsquo;固定\u0026rsquo; 的, 没法提供额外的信息; 交叉熵, 由于我们用 $e_{k^*}$ 替代了, 导致梯度没法直接计算. $$\rL = \\log p(x|z_q; \\Phi) + \\| \\text{sg} (\\phi(x)) - e_{k^*}\\|_2^2 +\r\\beta \\cdot \\| \\phi(x) - \\text{sg} (e_{k^*})\\|_2^2.\r$$ 这里 $\\text{sg}(\\cdot)$ 表示 stop-gradient 操作, $\\beta$ 是超参数 (默认为 0.25).\n注: straight-through estimator (STE):\nz_q = z + (z_q - z).detach() 代码 [PyTorch]\n","permalink":"http://localhost:1313/posts/vqvae/","title":"Neural Discrete Representation Learning"},{"content":"\r# 第一页\r这是第一页的内容看看看看看阿卡看看看看看看看看看看看看看看看看看看看看看看看\n### dier\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ### 333\r\u003cul\u003e \u003cli\u003e \u003cp\u003e为什么没有 bullet\n\u003cul\u003e \u003cli\u003eddd $$\rx + 1\r$$\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e ","permalink":"http://localhost:1313/slides/test/","title":"Slide-test"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"}]