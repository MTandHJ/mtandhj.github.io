[{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":" Navon A., Achituve I., Maron H., Chechik G. and Fetaya E. Auxiliary learning by implicit differentiation. ICLR, 2021.\n概 通过 implicit differentiation 优化一些敏感的参数.\n$$\r1 + 2f(x)\r\\phi \\ell_{main}\r$$\nAuxiLearn 在实际的训练中, 我们常常会通过一些额外的任务来帮助更好的训练. $$\r\\ell_{main}, \\bm{x}\r$$ 其中 $\\phi_k \\ge 0$ 是第 $k$ 个额外任务 $\\ell_k$ 的系数.\n$$\rw_{t+1} \\leftarrow \\arg \\min_{W} \\mathcal{L}_T(W; \\phi_t) \\phi_{t+1}\r$$ 但是很显然, 如果利用梯度下降学习 $\\phi_k$ 并通过 clip 保证 $\\phi_k \\ge 0$, 一定会导致 $\\phi_k \\equiv 0$ 这一平凡解.\n问题设定 现在让我们来设定一个更加一般的问题: $$\r\\ell_{main}(W; \\mathcal{D}_{train})\r$$ 其中 $W \\in \\mathbb{R}^n$ 是模型中的基本参数, $\\phi \\in \\mathbb{R}^m$ 是一些其它的超参数, 然后 $D_{train}, D_{aux}$ 表示训练集和额外的集合 (比如验证集).\n不考虑 mini-batch, 合理的训练流程应该是: 如此重复. 就能够避免 $\\phi$ 的平凡解.\n当然, 如果每一次都严格按照两阶段计算, 计算量是相当庞大的 (比 grid search 也是不遑多让). 本文所提出来的 AuxiLearn 的改进就是提出了一种近似方法. 它的理论基础是 Implicit Function Theorem (IFT).\n$$\r\\nabla_{\\phi} \\mathcal{L}_A = \\underbrace{\\nabla_W \\mathcal{L}_A}_{1 \\times n} \\cdot \\underbrace{\\nabla_{\\phi} W^*}_{n \\times m}.\r$$ 显然, 其中 $\\nabla_W \\mathcal{L}_A$ 是好计算的, 问题在于 $\\nabla_{\\phi} W^*$ 的估计.\n$$\rF(p, q) = 0,\r$$$$\rF(x, \\Phi(x)) = 0\r$$ 在某个集合上均成立.\n$$\r\\nabla_W \\mathcal{L}_T(W^*, \\phi) = 0,\r$$$$\r\\nabla_W \\mathcal{L}_T(W^*(\\phi), \\phi) = 0,\r$$$$\r\\nabla_{\\phi} \\nabla_W \\mathcal{L}_T(W^*(\\phi), \\phi) = 0 \\\\\r\\Rightarrow\r\\nabla_W^2 \\mathcal{L}_T \\cdot \\nabla_{\\phi} W^* + \\nabla_{\\phi} \\nabla_W \\mathcal{L}_T = 0 \\\\\r\\Rightarrow\r\\nabla_{\\phi} W^* = - (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_{\\phi} \\nabla_W \\mathcal{L}_T.\r$$ $$\r\\nabla_{\\phi} \\mathcal{L}_A = -\\underbrace{\\nabla_W \\mathcal{L}_A}_{1 \\times n} \\cdot \\underbrace{(\\nabla_W^2 \\mathcal{L}_T)^{-1}}_{n \\times n}) \\cdot \\underbrace{\\nabla_{\\phi} \\nabla_W \\mathcal{L}_T}_{n \\times m}.\r$$ $$\r(I - X)^{-1} = \\sum_{t} X^t \\Rightarrow X^{-1} = (I - (I - X))^{-1} = \\sum_{t} (I - X)^t.\r$$ 于是便得到了本文 AuxiLearn 算法 (算法 2 其实就是 Neumann series 的前 $J$ 项):\n理解两阶段的训练 $$\r\\mathcal{L}_T(W, \\phi) = \\ell_{main}(W; \\mathcal{D}_{train}) + \\phi \\cdot \\ell_{aux}(W; \\mathcal{D}_{train}).\r$$ $$\r\\begin{array}{ll}\r\\frac{d \\mathcal{L}_A}{d \\phi}\r\u0026= -\\nabla_W \\mathcal{L}_A \\cdot (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_{\\phi} \\nabla_W \\mathcal{L}_T \\\\\r\u0026= -\\nabla_W \\mathcal{L}_A \\cdot (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_{\\phi} (\\nabla_W \\mathcal{\\ell}_{main}(\\mathcal{D}_{train}) + \\phi \\nabla_W \\ell_{aux}) \\\\\r\u0026= -\\nabla_W \\mathcal{L}_A \\cdot (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_W^T \\mathcal{\\ell}_{aux}(\\mathcal{D}_{train}) \\\\\r\u0026= -\\nabla_W \\mathcal{L}_{main}(\\mathcal{D}_{aux}) \\cdot (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_W^T \\mathcal{\\ell}_{aux}(\\mathcal{D}_{train}). \\\\\r\\end{array}\r$$ $$\r\\nabla_W \\mathcal{L}_{main}(\\mathcal{D}_{aux}) \\cdot (\\nabla_W^2 \\mathcal{L}_T)^{-1} \\cdot \\nabla_W^T \\mathcal{\\ell}_{aux}(\\mathcal{D}_{train}) \u003e 0,\r$$ 即当主任务在 aux 集合上的更新方向和辅任务在训练集上在 $\\nabla_W^2 \\mathcal{L}_T^{-1}$ 意义上方向一致.\n代码 [official-code]\n","permalink":"http://localhost:1313/posts/test1/","title":"Test1"},{"content":"[TOC]\nChoi J., Wang Z., Venkataramani S., Chuang P. I., Srinivasan V. and Gopalakrishnan K. PACT: Parameterized clipping activation for quantized neural networks. 2018.\n概 本文提出对网络中的激活值进行裁剪以实现更低量化.\n主要内容 $$\ry = PACT(x) = 0.5 (|x| - |x - \\alpha| + \\alpha)\r=\\left \\{\r\\begin{array}{ll}\r0, \u0026 x \\in (-\\infty, 0), \\\\\rx, \u0026 x \\in [0, \\alpha), \\\\\r\\alpha, \u0026 x \\in [\\alpha, +\\infty).\r\\end{array}\r\\right .\r$$ $$\r\\frac{\\partial y_q}{\\partial \\alpha}\r=\\frac{\\partial y_q}{\\partial y}\r\\frac{\\partial y}{\\partial \\alpha}\r=\\left \\{\r\\begin{array}{ll}\r0, \u0026 x \\in (-\\infty, \\alpha), \\\\\r1, \u0026 x \\in [\\alpha, +\\infty].\r\\end{array}\r\\right.,\r$$ 其中 $y_q = round(y \\cdot \\frac{2^k - 1}{\\alpha}) \\cdot \\frac{\\alpha}{2^k - 1}$.\n","permalink":"http://localhost:1313/posts/test2/","title":"Test2"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"},{"content":"[TOC]\nChoi J., Wang Z., Venkataramani S., Chuang P. I., Srinivasan V. and Gopalakrishnan K. PACT: Parameterized clipping activation for quantized neural networks. 2018.\n概 本文提出对网络中的激活值进行裁剪以实现更低量化.\n主要内容 $$\ry = PACT(x) = 0.5 (|x| - |x - \\alpha| + \\alpha)\r=\\left \\{\r\\begin{array}{ll}\r0, \u0026 x \\in (-\\infty, 0), \\\\\rx, \u0026 x \\in [0, \\alpha), \\\\\r\\alpha, \u0026 x \\in [\\alpha, +\\infty).\r\\end{array}\r\\right .\r$$ $$\r\\frac{\\partial y_q}{\\partial \\alpha}\r=\\frac{\\partial y_q}{\\partial y}\r\\frac{\\partial y}{\\partial \\alpha}\r=\\left \\{\r\\begin{array}{ll}\r0, \u0026 x \\in (-\\infty, \\alpha), \\\\\r1, \u0026 x \\in [\\alpha, +\\infty].\r\\end{array}\r\\right.,\r$$ 其中 $y_q = round(y \\cdot \\frac{2^k - 1}{\\alpha}) \\cdot \\frac{\\alpha}{2^k - 1}$.\n","permalink":"http://localhost:1313/posts/test2/","title":"Test2"},{"content":" 廖雪峰Git教程\n初始化 在你想要git的文件夹内 git bash here\n接着注册\ngit config --global user.name \u0026#34;XXXXXX\u0026#34;\rgit config --global user.email \u0026#34;XXX@+++.com\u0026#34; 配置别名\ngit config --global alias.last \u0026#39;log -1\u0026#39;\rgit config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; 上面的步骤是第一次使用git, 若不是可省略\n将所在目录变成git可以管理的仓库\ngit init 在所在目录添加 .gitignore 文件, 一般可以直接在这儿选择所需要的就行, 特殊情况可以自己再加点定制\ngit add .gitignore\rgit commit -m \u0026#34;add .gitignore\u0026#34; 远程仓库 创建ssh key\nssh-keygen -t rsa -C \u0026#34;xxx@+++.com\u0026#34; 然后在主目录下找到.ssh目录里面的id_rsa.pub (公钥), 并复制文件里的内容.\n在GitHub的settings里面找到ssh keys (SSH and GPG keys)部分添加new ssh key\n在GitHub上新建repo, 并复制其ssh\n执行\ngit remote add origin ssh 将本地的内容推送到远程库上\ngit push -u origin master 分支管理 创建分支\ngit branch dev 或者(下面都是创建并移动至)\ngit switch -c dev 或者\ngit checkout -b dev 通过\ngit branch 查看当前的分支情况\n通过\ngit switch master 切换至master主分支\n合并分支\ngit merge dev 删除分支\ngit branch -d dev 多人协作 联系之前远程仓库的内容, 通过\ngit remote\rgit remote -v 来查看当前的远程仓库的信息.\n推送\ngit push origin master\rgit push origin dev 拷贝clone 这部分算是第二步, 模拟另外一个地方从头开始工作的情形.\n在某个目录下抓取\ngit clone ssh 查看分支\ngit branch 此时只有 master\n获得dev分支\ngit checkout -b dev origin/dev 然后在dev上进行操作, 并提交修改\n解决冲突 这个即为第三步\n首先如果直接提交本地的修改会出错, 因为版本不一致, 需要先抓取最新的提交\ngit pull 但是此时也不行, 因为当前有俩个分支, 所以需要声名抓的是哪一个\ngit branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; dev 我们这里就是\ngit branch --set-upstream-to=origin/dev dev 如果是在master上进行操作:\ngit branch --set-upstream-to=origin/master master 然后再\ngit pull 解决冲突, 会在文件中出现change, 得选择是否接受change\n提交修改\ngit push origin dev 标签 给某个commit打上标签\ngit tag v1.0 此时给最新的commit打上标签, 也可以\ngit tag v1.0 ef2a5d7 更具体的\ngit tag -a v1.0 -m \u0026#34;version 1.0\u0026#34; ef2a5d7 通过\ngit show v1.0 来查看对应的标签信息\n删除标签\ngit tag -d 另外:\n推送某个标签到远程\ngit push origin v1.0 一次性推送全部尚未推送到远程的本地标签\ngit push origin -tags 删除远程标签\n首先删除本地标签\ngit tag -d v1.0 然后从远程删除\ngit push origin :refs/tags/v1.0 版本回退 git reset git reset --hard HEAD^ 回退到上一版本, HEAD^^就是上上一版本, HEAD~100就是往上100个版本.\ngit reset --hard GPL GPL就是库的那一堆16位\ngit reset HEAD filename 把暂存区的修改撤销, 重新放回工作区, 或者用\ngit restore --staged filename git revert 类似于reset, 只是在\u0026quot;回退“版本的时候, 前面的版本信息不会丢失, 即\n​\tA -\u0026gt; B -\u0026gt; C\n现在想要回到B, reset后为\n​\tA -\u0026gt; B\nrevert后为\n​\tA -\u0026gt; B -\u0026gt; C -\u0026gt; B\n","permalink":"http://localhost:1313/posts/git/","title":"Git"}]